# MySQL数据库事务

[TOC]



## 1. 存储引擎InnoDB和MyISAM的比较

- InnoDB : **支持事务**，行锁（row-level locking），和外键。支持MVVC，应对高并发事务，MVVC比单纯的加锁更高效；
- MyISAM: 强调的是性能，**不支持事务**，只支持表级锁(table-level locking)。



## 2. 索引

MySQL索引使用的数据结构主要有**B Tree索引**和**哈希索引**。哈希索引底层使用的数据结构就是哈希表，因此在大多数需求为单条记录时，选择使用哈希索引，查询性能最快。其他大部分情况，建议选择B Tree索引。

MySQL的BTree索引主要使用的**B+Tree索引**。

- MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree索引算法搜索索引，如果指定的Key存在，则取出其data域的值，然后再根据data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

- InnoDB:其数据文件本身就是索引文件。B+Tree树中的叶节点保存了完整的数据记录，索引的Key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种索引也称为**聚簇索引**。其他的索引都是作为辅助索引，辅助索引的data域存储的是相应记录的主键而不是地址，这是与MyISAM索引不同的地方。**根据主索引搜索时，直接找到Key所在节点即可取出数据；根据辅助索引时，需要先找出主键的值，再走一遍主索引。因此，再设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主键索引频繁分裂。**



## 3. 数据库事务

### 3.1 什么是事务

事务是逻辑上的一组操作，要么都执行，要么都执行。

### 3.2 事务的特性

1. 原子性（Atomicity）：事务是最小的执行单元，不允许在分割。事务的原子性确保操作全部完成，或者全部不起作用。
2. 一致性（Consistency）：执行事务后，数据库从一个正确的状态变化到另一个正确的状态。
3. 隔离性（Isolation）：并发访问数据库时，一个事务的不被其他的事务所干扰，各并发事务之间数据库是独立的。
4. 持久性（Duration）：一个事务被提交后，它对数据库的改变是永久的，即使数据库发生故障也不该对其有影响。

### 3.3 并发事务带来的问题

在程序的运行过程中，多个事务并发运行，经常会操作相同的数据来完成各自的任务，可能会导致下列问题。

- 脏读（Dirty read）: 当一个事务正在访问数据库并对数据进行了修改，但还没提交该事务的时候，另一个事务也访问了该数据，然后使用了该数据。因为这个数据是还没提交的数据，那么另一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的修改可能是不正确的。
- 丢失修改（Lost to modify）: 指在一个事务中读取一个数据，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了该数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
- 不可重复读（Unreapeatable read）: 指在一个事务多次读取同一数据。在这个事务还没有结束时，另一个事务也在访问该数据。那么，在第一个事务中两次读取数据之间，由于第二个事务的修改导致第一个事务两次读取的数据不一样。这样就发生了在一个事务内两次读取到的数据不一致的情况，因此成为不可重复读。
- 幻读（Phantom read）： 幻读和不可重复读类似。它发生在一个事务（T1）读取了几行事务，接着另一个并发事务（T2）插入了一些数据。在随后的查询中，第一个事务（T1）就会发现多了一些原来不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读的区别：

不可重复读的重点是一个事务多次读取一条记录发现某些值被修改了，幻读的重点在于新增或删除，比如多次读取一条记录发现记录增多了或减少了，这些增加和减少的行叫做幻影（Phantom row）。

多个事务的并发会对事务的**隔离性**和**一致性**造成破坏，数据库需要对这些并发操作进行正确的并发控制，从而使一个事务的执行不受其他事务的干扰。

并发控制的主要技术有加锁（locking）、时间戳（timestamp）、乐观控制法（optimistic scheduler）和多版本并发控制（multi-version concurrency, MVVC）等

### 3.4 事务的隔离级别

SQL定义了四个隔离级别：

- **READ-UNCOMMITTED(未提交读)**：最低的隔离级别，允许读取尚未提交数据变更。**可能会导致脏读、不可重复读或幻读。**
- **READ-COMMITTED(已提交读)**：允许读取以提交的事务，**可以阻止脏读，但是不可重复读和幻读仍有可能发生。**
- **REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是本省事务自己所修改的，**可以防止脏读和不可重复读，但幻读仍有可能发生。**
- **SERIALIZABLE(串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次执行，因而事务之间不可能产生干扰，**可以防止脏读、不可重复读以及幻读**。

MySQL InnoDB存储引擎默认的隔离级别是**REPREATABLE-READ(可重复读)**。MySQL8可以通过`select @@transaction_isolation`,Mysql5可以通过以下命令来看：

```mysql
mysql> select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
1 row in set, 1 warning (0.00 sec)
```

MySQL设置session级别的隔离级别：

```mysql
mysql> set session transaction isolation level READ COMMITTED;
```

但值得注意的是，InnoDB存储引擎在**REPREATABLE-READ(可重复读)**的隔离级别下，也能防止幻读的产生，因为使用了Next-Key lock锁算法，这与其他的数据库是不同的。所以InnoDB的默认支持的隔离级别就已经完全保证了事务的隔离性要求，即达到了SQL标准的SERIALIZABLE（串行化）隔离级别。

> InnoDB存储引擎在**分布式事务**的情况下一般会用到SERIALIZABLE(串行化)隔离级别。

### 3.5 MySQL的锁机制

为什么要有锁？

锁是实现事务并发控制的一种重要技术。

MyISAM和InnoDB存储引擎使用的锁的区别：

- MyISAM采用表级锁（table-level locking）。
- InnoDB采用行级锁（row-level locking)和表级锁，默认使用的是行级索。

表级锁和行级锁的差别：

- 表级锁：MySQL中**锁定粒度最大**的一种锁，对当前操作的整张表加锁，实现简单，消耗资源也少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。

- 行级索：MySQL中**锁定粒度最小**的一种锁，只对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发读高，但加锁的开销也最大，加锁慢，会出现死锁。

  















---

参考文章：

1. (https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md)

